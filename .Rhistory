classp<-ifelse(glm_preds < .5, levels(pred_coords[,ngc])[1], levels(pred_coords[,ngc])[2])
tab2<-table(classp, pred_coords[-datsamp,ngc])
roc2<-roc(pred_coords[-datsamp,ngc], glm_preds)
auc_mat[i, 5]<-auc(roc2)
acc_mat[i, 5]<-sum(diag(tab2))/sum(tab2)
####svm method
svmMod<-svm(as.formula(paste(names(pred_coords)[ngc],"~.")), data = pred_coords[datsamp,], probability = TRUE)
ppred<-predict(svmMod, newdata = pred_coords[-datsamp,], probability = TRUE)
tab3<-table(ppred, pred_coords[-datsamp,ngc])
roc3<-roc(pred_coords[-datsamp,ngc], attr(ppred, "probabilities")[,2])
auc_mat[i, 6]<-auc(roc3)
acc_mat[i, 6]<-sum(diag(tab3))/sum(tab3)
#######WITH ORIGINAL COORDINATES
#####logistic original coordinates
dat[,-groupcol]<-scale(dat[-groupcol], center = TRUE, scale = TRUE) ####Advantage of centering and scaling data
####for svm used later
logistic_mod2<-glm(as.formula(paste(names(dat)[groupcol],"~.")),data = dat[datsamp,], family = "binomial")
glm_preds2<-predict(logistic_mod2, newdata = dat[-datsamp,], type = "response")
classp2<-ifelse(glm_preds2 < .5,levels(dat[,groupcol])[1], levels(dat[,groupcol])[2])
tab22<-table(classp2, dat[-datsamp,groupcol])
roc22<-roc(dat[-datsamp,groupcol], glm_preds2)
auc_mat[i, 7]<-auc(roc22)
acc_mat[i, 7]<-sum(diag(tab22))/sum(tab22)
####
####svm original coordinates
svmMod2<-svm(as.formula(paste(names(dat)[groupcol],"~.")), data = dat[datsamp,], probability = TRUE)
ppred2<-predict(svmMod2, newdata = dat[-datsamp,], probability = TRUE)
tab32<-table(ppred2, dat[-datsamp,groupcol])
roc32<-roc(dat[-datsamp,groupcol], attr(ppred2, "probabilities")[,2])
auc_mat[i, 8]<-auc(roc32)
acc_mat[i, 8]<-sum(diag(tab32))/sum(tab32)
}
#####
colnames(auc_mat)<-c("centroid", "logistic (smvcir)", "svm (smvcir)", "reducedCentroid",
"reducedlog", "reducedsvm", "logistic", "svm")
colnames(acc_mat)<-colnames(auc_mat)
return(list(acc_mat = acc_mat, auc_mat = auc_mat, seed = seed))
}
bboot<-bootit(groupcol = 1, dat = breast)
data("veteran", package = "randomForestSRC")
str(veteran)
VA<-veteran
VA$cell<-factor(as.numeric(veteran$celltype))
VA$treat<-factor(ifelse(veteran$trt==1, 0,1))
VA$therapy<-factor(ifelse(veteran$prior==0, 0, 1))
VA<-VA[,c(3,4,10,7,5,6,9,11)]
str(VA)
rfVA<-rfsrc(Surv(time, status)~., data = VA)
rfVA
plot.survival(rfVA)
?rfsrc
rfVA$survival
str(rfVA$survival)
plot(rfVA$chf)
?plot.survival
plot(rfVA$chf)
plot.survival(rfVA)
rfVA$membership
rfVA$predicted.oob
q()
library(MASS)
data(Boston)
newB<-Boston
newB$medcrim<-factor(ifelse(Boston$crim>median(Boston$crim), 1, 0))
newB<-newB[,-1]
##groupvar is first
newB<-newB[,c(14, 1:13)]
set.seed(20)
train<-createDataPartition(newB$medcrim, p = .8, list= FALSE)
library(caret)
set.seed(20)
train<-createDataPartition(newB$medcrim, p = .8, list= FALSE)
smv<-smvcir("medcrim", data = newB[train,], test = TRUE)
library(SMVCIR)
smv<-smvcir("medcrim", data = newB[train,], test = TRUE)
smv$statdim
smv$groupindex
smv$maxTRANScm
smv$coefficients
newB<-newB[,c(2:5, 1, 6:14)]
str(newB)
set.seed(20)
train<-createDataPartition(newB$medcrim, p = .8, list= FALSE)
smv<-smvcir("medcrim", data = newB[train,], test = TRUE)
smv$groupindex
plotcoords(smv, dimensions = 1:3, GL = TRUE, build_svm = TRUE, kernel = "radial")
plotcoords(smv, dimensions = 1:3, GL = FALSE, build_svm = TRUE, kernel = "radial")
?svm
library(SMVCIR)
plotcoords(smv, dimensions = 1:3, GL = FALSE, build_svm = TRUE, kernel = "radial")
wmat<-smv$direct
k = length(wmat[1, ]) - 1
k
dimensions = 1:3
mod_obj<-svm(x = wmat[,dimensions], y = wmat[,k+1], kernel = kernel, data = wmat)
dimensions
kernel = "radial"
mod_obj<-svm(x = wmat[,dimensions], y = wmat[,k+1], kernel = kernel, data = wmat)
mod_obj
slice<-lapply(wmat[,dimensions], median)
slice
def.par <- par(no.readonly = TRUE)
par(mai = c(0, 0, 0, 0))
totcol <- length(dimensions)
mat <- matrix(nrow = totcol, ncol = totcol)
ordering <- 1
for (i in 1:totcol) {
for (j in 1:totcol) {
mat[i, j] <- ordering
ordering <- ordering + 1
}
}
layout(mat, widths = rep(0.5, ncol(mat)), heights = rep(0.5,
ncol(mat)), respect = TRUE)
colors <- c("black", "red", "blue", "orange", "purple", "brown",
"green", "pink", "yellow", "aquamarine")
gsymbols <- c(0, 15, 2, 17, 3, 4, 8, 1, 16, 6)
for (i in 1:totcol) {
ls()
banksmv
x<-banksmv
dimensions<-1:3
if(class(x)=="smvcir"){
groupnum<-x$groups
groupcol<-ncol(x$direct)
compcases<-x$compcases
datmat<-x<-x$direct      ####add x double assignment
} else{
groupcol<-NA
for (i in 1:ncol(x)){
if (class(x[,i])=="factor"){
groupcol[i]<-i
} else{
groupcol[i]<-NA
}
}
groupcol<-groupcol[!is.na(groupcol)]
if(length(groupcol)>1)
stop("Only numerical predictors allowed for smvcir, appears you have more than one variable of class=='factor'")
if(length(groupcol)==0)
stop("Missing a dependent group variable of class=='factor' in your coordinates")
groupnum<-length(unique(x[,groupcol]))
datmat<-x
#datmat[,groupcol]<-as.numeric(datmat[,groupcol])
compcases <- data.frame(complete.cases(datmat)) ###look ahead check line 72
compcases <- cbind(compcases, t(t(1:nrow(datmat))))
}
k
groupcol
if (length(groups) >= groupnum) {
bx <- matrix("Rendering all Groups", 1, 1)
rownames(bx) <- ""
colnames(bx) <- ""
print(noquote(bx))
groups <- 1:(groupnum)
}
groups = 1:10
head(datmat)
str(datmat)
table(datmat$Y)
wmat = datmat
k = length(wmat[1, ]) - 1
k
kernel = "radial"
mod_obj<-svm(x = wmat[,dimensions], y = wmat[,k+1], kernel = kernel, data = wmat)
library(e1071)
mod_obj<-svm(x = wmat[,dimensions], y = wmat[,k+1], kernel = kernel, data = wmat)
#slice<-lapply(wmat[,1:k], median)
slice<-lapply(wmat[,dimensions], median)
}
def.par <- par(no.readonly = TRUE)
par(mai = c(0, 0, 0, 0))
totcol <- length(dimensions)
mat <- matrix(nrow = totcol, ncol = totcol)
ordering <- 1
for (i in 1:totcol) {
for (j in 1:totcol) {
mat[i, j] <- ordering
ordering <- ordering + 1
}
}
layout(mat, widths = rep(0.5, ncol(mat)), heights = rep(0.5,
ncol(mat)), respect = TRUE)
colors <- c("black", "red", "blue", "orange", "purple", "brown",
"green", "pink", "yellow", "aquamarine")
gsymbols <- c(0, 15, 2, 17, 3, 4, 8, 1, 16, 6)
for (i in 1:totcol) {
for (j in 1:totcol) {
if (i == j) {
if (i != totcol) {
plot(wmat[, dimensions[j]], wmat[, dimensions[j]],
type = "n", yaxt = "n", xlab = "", ylab = "")
legend("center", legend = c(dimensions[j]),
bty = "n", title = method)
axis(side = 4)
}
else {
plot(wmat[, dimensions[j]], wmat[, dimensions[j]],
type = "n", yaxt = "n", xaxt = "n", xlab = "",
ylab = "")
legend("center", legend = c(j), bty = "n",
title = method)
axis(side = 3)
}
}
else if (i > j) {
x <- c(0, 1)
plot(x, type = "n", axes = FALSE, xlab = "",
ylab = "")
legend("center", legend = c(" "), bty = "n",
title = "")
}
else {
coords = dimensions
k = length(wmat[1, ]) - 1
n = length(wmat[, 1])
zmat = wmat[, 1:k]
indi = wmat[, (k + 1)]
numg = max(as.numeric(indi)) ###add as.numeric()
ssgroup = rep(0, numg)
for (p in 1:numg) {
see = wmat[indi == levels(indi)[p], ]
ssgroup[p] = length(see[, 1])
}
xl = c(min(zmat), max(zmat))
yl = c(min(zmat), max(zmat))
newindi <- order(indi)
z1 <- zmat[, coords[i]]
z2 <- zmat[, coords[j]]
zz1 <- z1[newindi]
zz2 <- z2[newindi]
plot(zz2, zz1, xlab = "", ylab = "", pch = " ",
xlim = xl, ylim = yl, axes = FALSE)
if(build_svm==TRUE){
xr <- seq(xl[1], xl[2], length = 50)
yr <- seq(yl[1], yl[2], length = 50)
formala<-as.formula(paste(names(zmat)[i], "~", names(zmat)[j]))
lis <- c(list(yr), list(xr), slice)
names(lis)[1:2] <- colnames(wmat)[c(i,j)]
new <- expand.grid(lis)[, labels(terms(mod_obj))]
preds <- predict(mod_obj, new)
.filled.contour(xr,
yr,
matrix(as.numeric(preds),nrow = length(xr), byrow = TRUE),
levels = 1:length(levels(preds))+1,
col=colorpanel(3, low = "gray70", high = "gray45"))
}
ic <- 0
coli <- 0
for (p in 1:numg) {
there <- 0
for (m in 1:length(groups)) {
if (groups[m] == p) {
there <- 1
break
}
}
start <- ic + 1
stop <- ic + ssgroup[p]
coli <- coli + 1
if (there == 1) {
points(zz2[start:stop], zz1[start:stop],
col = colors[p], pch = gsymbols[p])
abline(lsfit(zz2[start:stop], zz1[start:stop]),
col = colors[p])
there <- 0
}
ic <- ic + ssgroup[p]
}
}
}
}
par(def.par)
method = "smvcir"
build_svm = TRUE
def.par <- par(no.readonly = TRUE)
par(mai = c(0, 0, 0, 0))
totcol <- length(dimensions)
mat <- matrix(nrow = totcol, ncol = totcol)
ordering <- 1
for (i in 1:totcol) {
for (j in 1:totcol) {
mat[i, j] <- ordering
ordering <- ordering + 1
}
}
layout(mat, widths = rep(0.5, ncol(mat)), heights = rep(0.5,
ncol(mat)), respect = TRUE)
colors <- c("black", "red", "blue", "orange", "purple", "brown",
"green", "pink", "yellow", "aquamarine")
gsymbols <- c(0, 15, 2, 17, 3, 4, 8, 1, 16, 6)
for (i in 1:totcol) {
for (j in 1:totcol) {
if (i == j) {
if (i != totcol) {
plot(wmat[, dimensions[j]], wmat[, dimensions[j]],
type = "n", yaxt = "n", xlab = "", ylab = "")
legend("center", legend = c(dimensions[j]),
bty = "n", title = method)
axis(side = 4)
}
else {
plot(wmat[, dimensions[j]], wmat[, dimensions[j]],
type = "n", yaxt = "n", xaxt = "n", xlab = "",
ylab = "")
legend("center", legend = c(j), bty = "n",
title = method)
axis(side = 3)
}
}
else if (i > j) {
x <- c(0, 1)
plot(x, type = "n", axes = FALSE, xlab = "",
ylab = "")
legend("center", legend = c(" "), bty = "n",
title = "")
}
else {
coords = dimensions
k = length(wmat[1, ]) - 1
n = length(wmat[, 1])
zmat = wmat[, 1:k]
indi = wmat[, (k + 1)]
numg = max(as.numeric(indi)) ###add as.numeric()
ssgroup = rep(0, numg)
for (p in 1:numg) {
see = wmat[indi == levels(indi)[p], ]
ssgroup[p] = length(see[, 1])
}
xl = c(min(zmat), max(zmat))
yl = c(min(zmat), max(zmat))
newindi <- order(indi)
z1 <- zmat[, coords[i]]
z2 <- zmat[, coords[j]]
zz1 <- z1[newindi]
zz2 <- z2[newindi]
plot(zz2, zz1, xlab = "", ylab = "", pch = " ",
xlim = xl, ylim = yl, axes = FALSE)
if(build_svm==TRUE){
xr <- seq(xl[1], xl[2], length = 50)
yr <- seq(yl[1], yl[2], length = 50)
formala<-as.formula(paste(names(zmat)[i], "~", names(zmat)[j]))
lis <- c(list(yr), list(xr), slice)
names(lis)[1:2] <- colnames(wmat)[c(i,j)]
new <- expand.grid(lis)[, labels(terms(mod_obj))]
preds <- predict(mod_obj, new)
.filled.contour(xr,
yr,
matrix(as.numeric(preds),nrow = length(xr), byrow = TRUE),
levels = 1:length(levels(preds))+1,
col=colorpanel(3, low = "gray70", high = "gray45"))
}
ic <- 0
coli <- 0
for (p in 1:numg) {
there <- 0
for (m in 1:length(groups)) {
if (groups[m] == p) {
there <- 1
break
}
}
start <- ic + 1
stop <- ic + ssgroup[p]
coli <- coli + 1
if (there == 1) {
points(zz2[start:stop], zz1[start:stop],
col = colors[p], pch = gsymbols[p])
abline(lsfit(zz2[start:stop], zz1[start:stop]),
col = colors[p])
there <- 0
}
ic <- ic + ssgroup[p]
}
}
}
}
par(def.par)
}
coords = dimensions
k = length(wmat[1, ]) - 1
n = length(wmat[, 1])
zmat = wmat[, 1:k]
indi = wmat[, (k + 1)]
numg = max(as.numeric(indi)) ###add as.numeric()
ssgroup = rep(0, numg)
for (p in 1:numg) {
see = wmat[indi == levels(indi)[p], ]
ssgroup[p] = length(see[, 1])
}
xl = c(min(zmat), max(zmat))
yl = c(min(zmat), max(zmat))
newindi <- order(indi)
z1 <- zmat[, coords[i]]
z2 <- zmat[, coords[j]]
zz1 <- z1[newindi]
zz2 <- z2[newindi]
numg
k
n
coords
plot(zz2, zz1, xlab = "", ylab = "", pch = " ",
xlim = xl, ylim = yl, axes = FALSE)
xr <- seq(xl[1], xl[2], length = 50)
yr <- seq(yl[1], yl[2], length = 50)
formala<-as.formula(paste(names(zmat)[i], "~", names(zmat)[j]))
formala
lis <- c(list(yr), list(xr), slice)
lis
names(lis)[1:2] <- colnames(wmat)[c(i,j)]
names(lis)
new <- expand.grid(lis)[, labels(terms(mod_obj))]
?paste
(nth <- paste0(1:12, c("st", "nd", "rd", rep("th", 9))))
names(wmat)[dimensions]
rep("+", length = dimensions)
rep("+", length = 3)
mod_obj<-svm(as.formula(paste(names(wmat)[k+1],"~", names(wmat)[dimensions],
sep = c(" ", rep("+", length = length(dimensions))))), kernel = kernel,
data = wmat)
mod_obj
formala
slice<-lapply(wmat[,dimensions], median)
slice
as.formula(paste(names(wmat)[k+1],"~", names(wmat)[dimensions],
sep = c(" ", rep("+", length = length(dimensions)))))
paste(names(wmat)[k+1],"~", names(wmat)[dimensions],
sep = c(" ", rep("+", length = length(dimensions))))
as.formula(c(paste(names(wmat)[k+1],"~"), paste(names(wmat)[dimensions],
sep = c(" ", rep("+", length = length(dimensions))))))
c(paste(names(wmat)[k+1],"~"), paste(names(wmat)[dimensions],
sep = c(" ", rep("+", length = length(dimensions)))))
c(paste(names(wmat)[k+1],"~"), paste(names(wmat)[dimensions],
sep = "+"))
paste(names(wmat)[dimensions],
sep = "+")
paste(names(wmat)[dimensions],
collapse = "+")
as.formula(c(paste(names(wmat)[k+1],"~"), paste(names(wmat)[dimensions],
collapse = "+")))
mod_obj<-svm(as.formula(c(paste(names(wmat)[k+1],"~"), paste(names(wmat)[dimensions],
collapse = "+"))), kernel = kernel,
data = wmat)
mod_obj
library(SMVCIR)
plotcoords(smv, dimensions = 1:3, GL = FALSE, build_svm = TRUE, kernel = "radial")
plotcoords(banksmv, dimensions = 1:3, GL = FALSE, build_svm = TRUE, kernel = "radial")
plotcoords(banksmv, dimensions = 1:2, GL = FALSE, build_svm = TRUE, kernel = "radial")
plotcoords(smv, dimensions = 1:3, GL = TRUE, build_svm = TRUE, kernel = "radial")
plotcoords(banksmv, dimensions = 1:3, GL = TRUE, build_svm = TRUE, kernel = "radial")
names(wmat)[dimensions]
svmx_string<-paste(names(wmat)[dimensions], collapse = "+")
svmx_string
library(SMVCIR)
plotcoords(banksmv, dimensions = 1:3, GL = TRUE, build_svm = TRUE, kernel = "radial")
pim.smv<-smvcir("diabetes", data = pima[train,], test = T) ###Build smvcir model on training set
preds<-predict(pim.smv, newdata = pima[-train,], type = "class")
table(preds, pima$diabetes[-train])  ###Check accuracy
library(e1071)
svmOb<-svm(diabetes~., data = pim.smv$direct, probability = TRUE,
kernel = "radial")
svmOb<-svm(diabetes~., data = pim.smv$direct[,c(1:3, 7)], probability = TRUE,
kernel = "radial")
str(pim.smv$direct)
svmOb<-svm(diabetes~., data = pim.smv$direct[,c(1:3, 9)], probability = TRUE,
kernel = "radial")
plotcoords(pim.smv, dimensions = 1:3, GL = TRUE, build_svm = TRUE, svmModel = svmModel)
plotcoords(pim.smv, dimensions = 1:3, GL = TRUE, build_svm = TRUE, svmModel = svmOb)
?plotcoords
library(SMVCIR)
?plotcoords
data(banknote)
###Create training rows for Banknote data
train<-sample(1:nrow(banknote), nrow(banknote)*.8, replace = FALSE)
####Build smvcir model on training set
banksmv<-smvcir("Y", data = banknote[train,], test = TRUE)
####Build svm model on first three dimensions of smvcir discriminant coordinates
svmModel<-svm(Y~., data = banksmv$direct[,c(1:3,7) ], probability = TRUE)
###Get discriminant coordinates from test set
bcoords<-predict(banksmv, newdata = banknote[-train,], coordinates_only = TRUE, maxdim = 3)
bcoords$Y<-banknote[-train,]$Y
####Plot test set coordinates with respect to svm model built from training set
plotcoords(bcoords, dimensions = 1:3, GL = TRUE, build_svm = TRUE, svmModel = svmModel)
library(SMVCIR)
?plotcoords
library(SMVCIR)
?plotcoords
library(SMVCIR)
plotcoords(banksmv, dimensions = 1:3, GL = FALSE, build_svm = TRUE, kernel = "radial")
library(SMVCIR)
svmModel<-svm(Y~., data = banksmv$direct[,c(1:3,7) ], probability = TRUE)
plotcoords(bcoords, dimensions = 1:3, GL = FALSE, build_svm = TRUE, svmModel = svmModel)
library(SMVCIR)
plotcoords(bcoords, dimensions = 1:3, GL = FALSE, build_svm = TRUE, svmModel = svmModel)
q()
library(MASS)
data(Boston)
newB<-Boston
newB$medcrim<-factor(ifelse(Boston$crim>median(Boston$crim), 1, 0))
newB<-newB[,-1]
##groupvar is first
newB<-newB[,c(14, 1:13)]
library(caret)
set.seed(20)
train<-createDataPartition(newB$medcrim, p = .8, list= FALSE)
smv<-smvcir("medcrim", data = newB[train,], test = TRUE)
library(SMVCIR)
smv<-smvcir("medcrim", data = newB[train,], test = TRUE)
plotcoords(smv, dimensions = 1:3, build_svm = TRUE)
plotcoords(smv, dimensions = 1:3, build_svm = TRUE, GL = TRUE)
Q()
q()
