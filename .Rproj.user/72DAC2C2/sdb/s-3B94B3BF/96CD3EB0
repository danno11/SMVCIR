{
    "contents" : "#'Main SMVCIR function\n#'\n#'Build a Sliced Mean Variance Covariance Inverse Regression model.\n#'\n#'@param group A character string specifying the name of the class variable of interest in your dataset.\n#'@param data  A data frame (including your group variable).\n#'@param pdt Percentage of SMVCIR discrimination desired from dimension\n#'@param level Level of dimensionality test\n#'@param test Types of tests, can use either, neither, or both.\n#'@param empsimss Number of draws to use in performing each dimensionality test.\n#'@param scree_plot If TRUE, a scree plot of cumulative percentage of variation explained by discriminant dimensions is produced.\n#'\n#'@examples\n#'\n#'\n#'library(caret)\n#'train<-createDataPartition(pima$diabetes, p = .8, list = FALSE)\n#'pim.smv<-smvcir(\"diabetes\", data = pima[train,], test = T) ###Build smvcir model on training set\n#'summary(pim.smv)\n#'\n#'@export\n\n\nsmvcir<-function (group, data, pdt = 100, level = 0.05, test = FALSE, scree_plot=FALSE)\n{\n  empTest = FALSE\n  apempTest = FALSE\n  if (test == TRUE) {\n    apempTest = TRUE\n  }\n  compcases <- data.frame(complete.cases(data))\n  compcases <- cbind(compcases, t(t(1:nrow(data))))\n  data_nu <- na.omit(data)\n  namelist <- attr(data, \"names\")\n  groupindex <- 0\n  for (i in 1:length(namelist)) {\n    if (namelist[i] == group) {\n      groupindex <- i\n      break\n    }\n  }\n  if (groupindex == 0) {\n    return(NAN)\n  }\n  if (groupindex == dim(data_nu)[2]) {\n    stage1readydat <- data.matrix(data_nu)\n  } else if (groupindex == 1) {\n    stage1readydat <- data.matrix(data_nu[, c(2:dim(data_nu)[2],\n                                              1)])\n  } else {\n    stage1readydat <- data.matrix(data_nu[, c(1:(groupindex -\n                                                   1), (groupindex + 1):dim(data_nu)[2], groupindex)])\n  }\n  rm(data_nu)\n  n <- dim(stage1readydat)[1]\n  k <- dim(stage1readydat)[2] - 1\n  g <- max(stage1readydat[, k + 1])\n  class_labels<-levels(data[,groupindex]) #####class_labels\n  standat <- cbind(scale(stage1readydat[, 1:k], center = TRUE,\n                         scale = TRUE), stage1readydat[, k + 1])\n  xbar <- t(t(colMeans(stage1readydat[, 1:k])))\n  sigmaminusoh <- matrix(0, nrow = k, ncol = k)\n  diag(sigmaminusoh) <- t(apply(stage1readydat[, 1:k], 2, sd))^(-1)\n  ind <- stage1readydat[, (k + 1)]\n  nupart = matrix(rep(0, k), ncol = 1)\n  deltapart = matrix(rep(0, k), ncol = 1)\n  storesigzi = matrix(rep(0, k), ncol = 1)\n  storecapdel = matrix(rep(0, k), ncol = 1)\n  storecapdel0 = matrix(rep(0, k), ncol = 1)\n  storevecd = matrix(rep(0, k), ncol = 1)\n  ni = rep(0, g)\n  for (i in 1:g) {\n    xg = stage1readydat[ind == i, 1:k]\n    ni[i] = length(xg[, 1])\n    xbari = t(t(colMeans(xg)))\n    zbari = sigmaminusoh %*% (xbari - xbar)\n    sigzi <- sigmaminusoh %*% var(xg) %*% sigmaminusoh\n    storesigzi = cbind(storesigzi, sigzi)\n    vecd = diag(sigzi)\n    storevecd = cbind(storevecd, vecd)\n    nui = sqrt(ni[i]/n) * zbari\n    nupart = cbind(nupart, nui)\n  }\n  nupart = nupart[, 2:(g + 1)]\n  storevecd = storevecd[, 2:(g + 1)]\n  storesigzi = storesigzi[, 2:(k * g + 1)]\n  sigzbar = matrix(rep(0, k^2), ncol = k)\n  ib = 1\n  ie = k\n  for (i in 1:g) {\n    sigzbar = sigzbar + (ni[i]/n) * storesigzi[, ib:ie]\n    ib = ib + k\n    ie = ie + k\n  }\n  sigzbard = diag(sigzbar)\n  ib = 1\n  ie = k\n  for (i in 1:g) {\n    deli = sqrt(ni[i]/n) * (storevecd[, i] - sigzbard)\n    deltapart = cbind(deltapart, deli)\n    capdeli = sqrt(ni[i]/n) * (storesigzi[, ib:ie] - sigzbar)\n    capdeli0 = capdeli - diag(diag(capdeli))\n    storecapdel <- cbind(storecapdel, capdeli)\n    storecapdel0 <- cbind(storecapdel0, capdeli0)\n    ib = ib + k\n    ie = ie + k\n  }\n  deltapart <- deltapart[, 2:(g + 1)]\n  storecapdel <- storecapdel[, 2:(k * g + 1)]\n  storecapdel0 <- storecapdel0[, 2:(k * g + 1)]\n  spansetF = cbind(storecapdel0, deltapart, nupart)\n  kernelF = spansetF %*% t(spansetF)\n  if (empTest == TRUE | apempTest == TRUE) {\n    estclt <- feststdclt1(g, stage1readydat)\n    estgrpmom <- eststddelta1(list(eu = estclt$eu, gprop = estclt$gprop,\n                                   g = estclt$g, k = estclt$k))\n    gprop = estclt$gprop\n    estvar <- eststddelta2(list(ef = estgrpmom$ef, g = g,\n                                k = k, gprop = gprop))\n    eststd <- eststddelta3(list(ef = estvar$ef, g = g, k = k,\n                                gprop = gprop))\n    estcentvar <- eststddelta4(list(ef = eststd$ef, g = g,\n                                    k = k, gprop = gprop))\n    estpropwt <- eststddelta5(list(ef = estcentvar$ef, g = g,\n                                   k = k, gprop = gprop))\n    eststackvarint <- eststackvar(list(ef = estpropwt$ef,\n                                       g = g, k = k, gprop = gprop))\n    vals <- eigen(kernelF, symmetric = TRUE)$values\n    or <- rev(order(abs(vals)))\n    evalues <- vals[or]\n    esteigensmvcir1 <- evalues\n  }\n  tmp = svd(spansetF)\n  sumsing = rep(0, k)\n  for (j in 1:k) {\n    sumsing[j] = sum(tmp$d[1:j])\n  }\n  sumsing = (100/sumsing[k]) * sumsing\n  scree = cbind(1:k, sumsing)\n  dpDIM = -1\n  for (j in 1:k) {\n    if (sumsing[j] >= pdt & dpDIM == -1) {\n      dpDIM = j\n    }\n  }\n  if (dpDIM == -1) {\n    dpDIM = k\n  }\n  if (scree_plot == TRUE) {\n    x11()\n    plot(c(0, scree[, 1]), c(0, scree[, 2]), xlab = \"Singular value\",\n         ylab = \"Percentage\", ylim = c(0, 100), type = \"l\",\n         main = \"Scree Plot SV %\")\n    abline(h = pdt)\n  }\n  emppvals <- matrix(NA, nrow = k, ncol = 1)\n  apemppvals <- matrix(NA, nrow = k, ncol = 1)\n  if (empTest == TRUE | apempTest == TRUE) {\n    vf <- matrix(0, nrow = g * k + g * k * k + g * k, ncol = g *\n                   k + g * k * k + g * k)\n    vf[(1:(g * k + g * k * k)), (1:(g * k + g * k * k))] <- (estpropwt$d5 %*%\n                                                               estcentvar$d4 %*% eststd$d3 %*% estvar$d2 %*% estgrpmom$d1 %*%\n                                                               estclt$vu %*% t(estgrpmom$d1) %*% t(estvar$d2) %*%\n                                                               t(eststd$d3) %*% t(estcentvar$d4) %*% t(estpropwt$d5))\n    for (i in 1:k) {\n      tstat <- n * sum(esteigensmvcir1[(i):length(esteigensmvcir1)])\n      tsmvcird <- i - 1\n      bigK <- kunstack(k, as.matrix(eststackvarint$ef))\n      sv <- svd(bigK, nu = nrow(bigK), nv = ncol(bigK))\n      gammanot <- sv$u[, (tsmvcird + 1):(ncol(sv$u))]\n      psinot <- sv$v[, (tsmvcird + 1):ncol(sv$v)]\n      dcmat <- ((t(psinot) %x% t(gammanot)) %*% eststackvarint$Perm %*%\n                  vf %*% t(eststackvarint$Perm) %*% (psinot %x%\n                                                       gammanot))\n      if (empTest == TRUE) {\n        devalues <- eigen(dcmat, symmetric = TRUE)$values\n        exceed = 0\n        for (j in 1:empsimss) {\n          realz <- t(devalues) %*% t(t(rchisq(length(devalues),\n                                              1)))\n          if (realz >= tstat) {\n            exceed <- exceed + 1\n          }\n        }\n        pvalue <- exceed/empsimss\n        emppvals[i, 1] <- pvalue\n      }\n      if (apempTest == TRUE) {\n        trdcmat <- sum(eigen(dcmat, symmetric = TRUE)$values)\n        trdcmat2 <- sum(eigen(dcmat %*% t(dcmat), symmetric = TRUE)$values)\n        d_num <- round((trdcmat^2)/trdcmat2)\n        scalecorrectstat <- tstat * ((trdcmat/d_num)^(-1))\n        pvalue <- 1 - pchisq(scalecorrectstat, d_num)\n        apemppvals[i, 1] <- pvalue\n      }\n    }\n  }\n  tmp.eig = eigen(kernelF)\n  wmati = standat[, 1:k] %*% tmp.eig$vectors\n  wmati = cbind(wmati, standat[, k + 1])\n  stdcoeffmat <- matrix(NA, nrow = k, ncol = k)\n  x <- cbind(scale(stage1readydat[, 1:k], center = TRUE, scale = TRUE),\n             rep(1, nrow(stage1readydat[, 1:k])))\n  for (i in 1:k) {\n    stdcoeffmat[1:k, i] <- t(t(lm.fit(y = wmati[, i], x = x)$coefficients[1:k]))[1:k,\n                                                                                 1]\n    norm <- sum(stdcoeffmat[1:k, i] * stdcoeffmat[1:k, i])\n    stdcoeffmat[1:k, i] <- stdcoeffmat[1:k, i]/sqrt(norm)\n  }\n  if (empTest == TRUE | apempTest == TRUE) {\n    if (empTest == TRUE) {\n      empDIM = -1\n      for (i in 1:k) {\n        if (emppvals[i] >= level & empDIM == -1) {\n          empDIM = i - 1\n        }\n      }\n      if (empDIM == -1) {\n        empDIM = k\n      }\n    }\n    else {\n      empDIM = -1\n    }\n    if (apempTest == TRUE) {\n      apempDIM = -1\n      for (i in 1:k) {\n        if (apemppvals[i] >= level & apempDIM == -1) {\n          apempDIM = i - 1\n        }\n      }\n      if (apempDIM == -1) {\n        apempDIM = k\n      }\n    }\n    else {\n      apempDIM = -1\n    }\n    chosenDIM = max(empDIM, apempDIM)\n  }\n  printit1 <- matrix(\"\", 7, 1)\n  printit1[1, 1] <- \"SMVCIR\"\n  printit1[2, 1] <- paste(\"# Groups:                \", g, sep = \"\")\n  printit1[3, 1] <- paste(\"# Predictors:            \", k, sep = \"\")\n  printit1[4, 1] <- paste(\"Observations used:     \", nrow(standat),\n                         sep = \"\")\n  printit1[5, 1] <- paste(\"Total Observations:    \", nrow(data),\n                         sep = \"\")\n  if (empTest == TRUE | apempTest == TRUE) {\n    printit1[6, 1] <- paste(\"Dimension: \", chosenDIM, \", at level: \",\n                           level, sep = \"\")\n  }\n  printit1[7, 1] <- paste(\"Dimension: \", dpDIM, \", provides \",\n                         round(sumsing[dpDIM], 0), \"% Discrimination\", sep = \"\")\n  rownames(printit1) <- rep(\"\", 7)\n  colnames(printit1) <- rep(\"\", 1)\n  #print(printit1, quote = FALSE)  ##First output for summary function\n  pvalmat<-NULL\n  if (empTest == TRUE | apempTest == TRUE) {\n    printit2 <- matrix(\"\", 1, 1)\n    printit2[1, 1] <- \"Dimensionality Test P-Values\"\n    rownames(printit2) <- c(\"\")\n    colnames(printit2) <- c(\"\")\n    #print(printit2, quote = FALSE)\n    if (apempTest == TRUE & empTest == TRUE) {\n      pvalmat <- round(cbind(emppvals, apemppvals), 3)\n      colnames(pvalmat) <- c(\"Empirical\", \"Approximate Empirical\")\n    }\n    else if (apempTest == TRUE) {\n      pvalmat <- round(t(t(apemppvals)), 3)\n      colnames(pvalmat) <- c(\"Approximate Empirical\")\n    }\n    else {\n      pvalmat <- round(t(t(emppvals)), 3)\n      colnames(pvalmat) <- c(\"Empirical\")\n    }\n    rownamesIt <- 0:(k - 1)\n    if (empDIM > -1) {\n      if (empDIM < k) {\n        rownamesIt[empDIM + 1] <- paste(\"E \", rownamesIt[empDIM +\n                                                           1], sep = \"\")\n      }\n    }\n    if (apempDIM > -1) {\n      if (apempDIM < k) {\n        rownamesIt[apempDIM + 1] <- paste(\"AE \", rownamesIt[apempDIM +\n                                                              1], sep = \"\")\n      }\n    }\n    rownames(pvalmat) <- rownamesIt\n    #print(pvalmat, quote = FALSE)\n  }\n  prednames <- rep(\"\", k)\n  i = 1\n  for (j in 1:(k + 1)) {\n    if (names(data)[j] != group) {\n      prednames[i] <- names(data)[j]\n      i = i + 1\n    }\n  }\n  rownames(stdcoeffmat) <- prednames\n  colnames(stdcoeffmat) <- paste(\"D\", 1:k, sep = \"\")\n  #printit <- matrix(\"\", 1, 1)\n  #printit[1, 1] <- \"Standardized Coefficients\"\n  #rownames(printit) <- c(\"\")\n  #colnames(printit) <- c(\"\")\n  #print(printit, quote = FALSE)\n  # if (empTest == TRUE | apempTest == TRUE) {\n  #   print(round(stdcoeffmat[, 1:max(min(chosenDIM, dpDIM),\n  #                                  1)], 3), quote = FALSE)\n  #}\n  #else {\n  #  print(round(stdcoeffmat[, 1:(max(dpDIM, 1))], 3), quote = FALSE)\n  #}\n  colnames(stage1readydat) <- c(prednames, group)\n  colnames(standat) <- c(prednames, group)\n  transdat <- data.frame(wmati)\n  names(transdat) <- c(paste(\"D\", rep(1:k), sep = \"\"), group)\n  spanFnames <- character(length = ncol(spansetF))\n  nb <- ncol(spansetF)\n  for (p in 1:nb) {\n    if (p <= g * k) {\n      if (floor(p/k) < p/k) {\n        tempgroup <- floor(p/k) + 1\n        covcolm <- p - floor(p/k) * k\n      }\n      else {\n        tempgroup <- floor(p/k)\n        covcolm = k\n      }\n      spanFnames[p] <- paste(\"C\", tempgroup, \".\", covcolm,\n                             sep = \"\")\n    }\n    else if (p <= g * k + g) {\n      tempgroup <- p - g * k\n      spanFnames[p] <- paste(\"V\", tempgroup, sep = \"\")\n    }\n    else {\n      tempgroup <- p - g * k - g\n      spanFnames[p] <- paste(\"M\", tempgroup, sep = \"\")\n    }\n  }\n  colnames(spansetF) <- spanFnames\n  if (empTest == TRUE | apempTest == TRUE) {\n    if (min(chosenDIM, dpDIM) > 1) {\n      TRANScm <- cor(transdat[, 1:(max(min(chosenDIM, dpDIM),\n                                       1))])\n      maxit <- max(TRANScm - diag(diag(TRANScm)))\n      minit <- min(TRANScm - diag(diag(TRANScm)))\n      if (abs(minit) > maxit) {\n        maxTRANScm <- minit\n      }\n      else {\n        maxTRANScm <- maxit\n      }\n    }\n    else {\n      TRANScm <- 0\n      maxTRANScm <- 0\n    }\n  }\n  else {\n    if (dpDIM > 1) {\n      TRANScm <- cor(transdat[, 1:dpDIM])\n      maxit <- max(TRANScm - diag(diag(TRANScm)))\n      minit <- min(TRANScm - diag(diag(TRANScm)))\n      if (abs(minit) > maxit) {\n        maxTRANScm <- minit\n      }\n      else {\n        maxTRANScm <- maxit\n      }\n    }\n    else {\n      TRANScm <- 0\n      maxTRANScm <- 0\n    }\n  }\n  printit <- matrix(\"SMVCIR dimensions should have low correlations.\",\n                    1, 1)\n  rownames(printit) <- c(\"\")\n  colnames(printit) <- c(\"\")\n  #print(printit, quote = FALSE)\n  printit <- matrix(paste(\"Maximum SMVCIR dimension correlation: \",\n                          maxTRANScm, sep = \"\"), 1, 1)\n  rownames(printit) <- c(\"\")\n  colnames(printit) <- c(\"\")\n  #print(printit, quote = FALSE)\n  printit <- matrix(\"SMVCIR correlations.\", 1, 1)\n  rownames(printit) <- c(\"\")\n  colnames(printit) <- c(\"\")\n  #print(printit, quote = FALSE)\n  #print(TRANScm, quote = FALSE) remove printing of discrim coords (too large)\n  if (empTest == FALSE & apempTest == FALSE) {\n    chosenDIM = NA\n  }\n  c_mat<-tmp.eig$vectors\n  muhat_ls<-aggregate(scale(stage1readydat[,1:k]), list(stage1readydat[,k+1]), mean)\n  muhat_ls<-matrix(NA, nrow = g, ncol = k)\n  for(i in 1:g){\n    muhat_ls[i,1:k] <- colMeans(standat[ind==i,1:k])\n  }\n  rownames(muhat_ls)<-levels(data[,which(names(data)%in%group)])\n  colnames(muhat_ls)<-prednames\n  muhat_z<-muhat_ls%*%c_mat\n  rownames(muhat_z)<-rownames(muhat_ls)\n  colnames(muhat_z)<-paste(\"D\", 1:k, sep = \"\")\n  sighatx<-cov(standat[,1:k])\n  sighatz<-t(c_mat)%*%sighatx%*%c_mat\n  class.props<-matrix(NA, ncol = g)\n  for(i in 1:g){\n    class.props[1,i]<-mean(standat[,k+1]==i)\n  }\n colnames(class.props)<-class_labels\n colnames(sighatz)<-rownames(sighatz)<-c(paste(\"D\", rep(1:k), sep = \"\"))\n\n  #if (plot == TRUE) {\n  #  if (GL) {\n  #   plot(smv, dimensions = 1:3, GL = GL)\n  # }\n  # else {\n  #   if (empTest == TRUE | apempTest == TRUE) {\n  #     plot(smv, dimensions = 1:max(min(chosenDIM, dpDIM),\n  #                                  1), GL = GL)\n  #   }\n  #   else {\n  #     plot(smv, dimensions = 1:max(dpDIM, 1), GL = GL)\n  #   }\n  # }\n  #}#\n  transdat[,k+1]<-factor(class_labels[transdat[,k+1]])\n  if(is.null(pvalmat)){pvalmat<-\"No dimensionality test performed\"}\n  smv <-list(groups = g, predictors = k, statdim = chosenDIM,\n              sighatz = sighatz, muhat_z = muhat_z, groupindex = groupindex,\n              class.props=class.props,\n              muhat_ls = muhat_ls, xbar = xbar, sighatx = sighatx,\n              dimCorr = TRANScm, maxTRANScm = maxTRANScm,\n              direct = transdat, compcases = compcases, spansetF = spansetF,\n              call = match.call(), coefficients = stdcoeffmat, originalx = stage1readydat[,1:k],\n              kernel = kernelF, summary1 = noquote(printit1), pvalmat = pvalmat)###switch kernel & kernelF\n  attr(smv, \"class\") <- \"smvcir\"\n  smv\n}\n",
    "created" : 1464106543524.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2097745996",
    "id" : "96CD3EB0",
    "lastKnownWriteTime" : 1464538994,
    "path" : "C:/Users/Dan/Desktop/smvcir/smvcir_funcs/SMVCIR/R/mainfuncv3.R",
    "project_path" : "R/mainfuncv3.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}